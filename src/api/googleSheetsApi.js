import { GoogleSpreadsheet } from 'google-spreadsheet';
import { SHEET_CONFIG } from '../utils/sheetValidation';
import { v4 as uuidv4 } from 'uuid';
import { formConfigs } from '../utils/formUtils';

// Debug logging setup
const DEBUG = true;

const logDebug = (...args) => {
  if (DEBUG) {
    console.log('[DEBUG]', ...args);
  }
};

// Track API calls
const logAPICall = async (operation, sheetName, data) => {
  if (DEBUG) {
    console.group(`📡 API Call: ${operation}`);
    console.log('Sheet:', sheetName);
    console.log('Data:', data);
    console.time('Operation Duration');
    try {
      const result = await data;
      console.log('Result:', result);
      return result;
    } finally {
      console.timeEnd('Operation Duration');
      console.groupEnd();
    }
  }
  return data;
};

export const SHEET_NAMES = {
  ENTITIES: 'ENTITIES',
  EVENTS: 'EVENTS',
  THEORY: 'THEORY',
  TIMELINES: 'TIMELINES',
  TIMELINE_REGISTRY: 'TIMELINE_REGISTRY',
  TIMELINE_GRID: 'TIMELINE_GRID'
};

const SPREADSHEET_ID = process.env.REACT_APP_GOOGLE_SHEETS_ID;
const CLIENT_EMAIL = process.env.REACT_APP_GOOGLE_SERVICE_ACCOUNT_EMAIL;
const PRIVATE_KEY = process.env.REACT_APP_GOOGLE_PRIVATE_KEY?.replace(/\\n/g, '\n');

const doc = new GoogleSpreadsheet(SPREADSHEET_ID);
let isInitialized = false;

const initializeAuth = async () => {
  if (isInitialized) return true;
  
  try {
    await doc.useServiceAccountAuth({
      client_email: CLIENT_EMAIL,
      private_key: PRIVATE_KEY,
    });
    await doc.loadInfo();
    isInitialized = true;
    return true;
  } catch (error) {
    console.error('Auth Error:', error);
    throw error;
  }
};

const transformRowData = (sheetName, rowData) => {
  const config = SHEET_CONFIG[sheetName];
  const transformedData = {};

  // Debug multi-select fields
  console.group('🔍 Transforming Row Data');
  console.log('Original data:', rowData);

  Object.entries(config.fields).forEach(([fieldName, fieldConfig]) => {
    let value = rowData[fieldName];

    // Handle multi-select fields
    if (fieldConfig.type === 'multiSelect' && Array.isArray(value)) {
      value = value.join(', ');
      console.log(`Transformed ${fieldName}:`, value);
    }

    // Handle auto-generated fields
    if (fieldConfig.auto && fieldConfig.transform) {
      value = fieldConfig.transform();
    }

    transformedData[fieldName] = value || '';
  });

  console.log('Transformed data:', transformedData);
  console.groupEnd();

  return transformedData;
};

export const prepareFormDataForSheet = (sheetName, formData) => {
  const transformedData = { ...formData };

  // Auto-generate fields
  if (!transformedData.event_id) {
    transformedData.event_id = uuidv4();
  }

  // Remove hidden/auto-generated fields
  Object.keys(transformedData).forEach((key) => {
    if (eventFormConfig[key]?.autoGenerated || !eventFormConfig[key]?.visible) {
      delete transformedData[key];
    }
  });

  return transformedData;
};

export async function addRowToSheet(sheetName, formData) {
  const formConfig = formConfigs[sheetName];
  if (!formConfig) {
    throw new Error(`No form configuration found for sheet: ${sheetName}`);
  }

  // Auto-generate fields
  Object.entries(formConfig).forEach(([fieldName, fieldConfig]) => {
    if (fieldConfig.autoGenerated) {
      formData[fieldName] = fieldConfig.defaultValue || new Date().toISOString();
    }
  });

  // Prepare the payload for submission
  const payload = {};
  for (const [fieldName, fieldConfig] of Object.entries(formConfig)) {
    if (fieldConfig.visible !== false && !fieldConfig.autoGenerated) {
      payload[fieldName] = formData[fieldName] || '';
    }
  }

  // Simulate API call to Google Sheets
  console.log(`Submitting data to sheet: ${sheetName}`, payload);
  // Replace this with actual API call logic
  return Promise.resolve({ success: true });
}

// Function to fetch data from a specific Google Sheet
export const fetchSheetData = async (sheetName) => {
  try {
    console.log(`Fetching data from sheet: ${sheetName}`);
    await initializeAuth();
    const sheet = doc.sheetsByTitle[sheetName];
    if (!sheet) {
      console.error(`Sheet "${sheetName}" not found in spreadsheet`);
      throw new Error(`Sheet with name "${sheetName}" not found`);
    }

    console.log(`Found sheet "${sheetName}", getting rows...`);
    const rows = await sheet.getRows();
    console.log(`Retrieved ${rows.length} rows from sheet "${sheetName}"`);
    
    const processedRows = rows.map(row => {
      const rowData = {};
      Object.keys(row).forEach(key => {
        if (key !== '_rawData' && key !== '_sheet' && key !== '_rowNumber') {
          rowData[key] = row[key];
        }
      });
      return rowData;
    });
    
    console.log(`Processed ${processedRows.length} rows from sheet "${sheetName}"`);
    return processedRows;
  } catch (error) {
    console.error(`Error fetching data from sheet "${sheetName}":`, error);
    throw error;
  }
};

// Update getSheetData to use fetchSheetData
export const getSheetData = async (sheetName) => {
  try {
    logDebug('Fetching sheet data', { sheetName });
    const data = await fetchSheetData(sheetName);
    logDebug('Sheet data fetched', { rowCount: data.length });
    return data;
  } catch (error) {
    console.error('getSheetData Error:', error);
    logDebug('Failed to fetch sheet data', { error });
    throw error;
  }
};

export const getSheetHeaders = async (sheetName) => {
  try {
    await initializeAuth();
    const sheet = doc.sheetsByTitle[sheetName];
    
    if (!sheet) {
      throw new Error(`Sheet "${sheetName}" not found`);
    }

    return SHEET_CONFIG[sheetName].displayOrder;
  } catch (error) {
    console.error('getSheetHeaders Error:', error);
    throw error;
  }
};

export const addIssue = async (issueData) => {
    const response = await fetch("/api/issues", {
        method: "POST",
        body: JSON.stringify(issueData),
        headers: { "Content-Type": "application/json" },
    });
    return response.json();
};

export const getIssues = async () => {
    const response = await fetch("/api/issues");
    return response.json();
};

export const updateIssue = async (issueId, updatedData) => {
    const response = await fetch(`/api/issues/${issueId}`, {
        method: "PUT",
        body: JSON.stringify(updatedData),
        headers: { "Content-Type": "application/json" },
    });
    return response.json();
};

export const deleteIssue = async (issueId) => {
    const response = await fetch(`/api/issues/${issueId}`, {
        method: "DELETE",
    });
    return response.json();
};

export const addStruggle = async (struggleData) => {
    const response = await fetch("/api/struggles", {
        method: "POST",
        body: JSON.stringify(struggleData),
        headers: { "Content-Type": "application/json" },
    });
    return response.json();
};

export const getStruggles = async () => {
  try {
    const rows = await fetchSheetData('STRUGGLES');
    return rows.map(row => ({
      id: row.struggle_id,
      name: row.struggle_name,
      type: row.struggle_type,
      subtype: row.subtype,
      description: row.struggle_description,
      active_range: row.active_range,
      parent_structure: row.parent_structure,
      primary_terrain: row.primary_terrain,
      root_contradiction: row.root_contradiction,
      linked_contradictions: row.linked_contradictions ? row.linked_contradictions.split(',').map(id => id.trim()) : [],
      linked_structures: row.linked_structures ? row.linked_structures.split(',').map(id => id.trim()) : [],
      linked_entities: row.linked_entities ? row.linked_entities.split(',').map(id => id.trim()) : [],
      linked_events: row.linked_events ? row.linked_events.split(',').map(id => id.trim()) : [],
      linked_issues: row.linked_issues ? row.linked_issues.split(',').map(id => id.trim()) : [],
      flashpoints: row.flashpoints ? row.flashpoints.split(',').map(id => id.trim()) : [],
      form: row.form,
      scale: row.scale,
      sector: row.sector,
      historical_development: row.historical_development,
      period: row.period,
      current_status: row.current_status,
      outcome: row.outcome,
      narratives_shaping: row.narratives_shaping_struggle ? row.narratives_shaping_struggle.split(',').map(id => id.trim()) : []
    }));
  } catch (error) {
    console.error('Error fetching struggles:', error);
    throw error;
  }
};

export const updateStruggle = async (struggleId, updatedData) => {
    const response = await fetch(`/api/struggles/${struggleId}`, {
        method: "PUT",
        body: JSON.stringify(updatedData),
        headers: { "Content-Type": "application/json" },
    });
    return response.json();
};

export const deleteStruggle = async (struggleId) => {
    const response = await fetch(`/api/struggles/${struggleId}`, {
        method: "DELETE",
    });
    return response.json();
};

export const addContradiction = async (contradictionData) => {
    const response = await fetch("/api/contradictions", {
        method: "POST",
        body: JSON.stringify(contradictionData),
        headers: { "Content-Type": "application/json" },
    });
    return response.json();
};

export const getContradictions = async () => {
  try {
    const rows = await fetchSheetData('CONTRADICTIONS');
    return rows.map(row => ({
      id: row.contradiction_id,
      name: row.contradiction_name,
      cluster: row.contradiction_cluster,
      type: row.contradiction_type,
      subtype: row.subtype,
      primary_domain: row.primary_domain,
      root_structure: row.root_structure,
      category_of_root_structure: row.category_of_root_structure,
      dominant_side: row.dominant_side,
      dominated_side: row.dominated_side,
      description: row.contradiction_description,
      rupture_date: row.rupture_date,
      first_major_flashpoint_event_id: row.first_major_flashpoint_event_id,
      timeline_ids: row.timeline_ids ? row.timeline_ids.split(',').map(id => id.trim()) : [],
      timeline_registry_ids: row.timeline_registry_ids ? row.timeline_registry_ids.split(',').map(id => id.trim()) : [],
      struggle_ids: row.struggle_ids ? row.struggle_ids.split(',').map(id => id.trim()) : [],
      linked_issues: row.linked_issues ? row.linked_issues.split(',').map(id => id.trim()) : [],
      entity_ids: row.entity_ids ? row.entity_ids.split(',').map(id => id.trim()) : [],
      intensity: row.contradiction_intensity,
      priority: row.contradiction_priority,
      historical_motion: row.historical_motion,
      status: row.status,
      theory_ids: row.theory_ids ? row.theory_ids.split(',').map(id => id.trim()) : [],
      timeline_relevance: row.timeline_relevance ? row.timeline_relevance.split(',').map(id => id.trim()) : [],
      narratives_highlighted: row.narratives_highlighted_by_contradiction ? row.narratives_highlighted_by_contradiction.split(',').map(id => id.trim()) : []
    }));
  } catch (error) {
    console.error('Error fetching contradictions:', error);
    throw error;
  }
};

export const updateContradiction = async (contradictionId, updatedData) => {
    const response = await fetch(`/api/contradictions/${contradictionId}`, {
        method: "PUT",
        body: JSON.stringify(updatedData),
        headers: { "Content-Type": "application/json" },
    });
    return response.json();
};

export const deleteContradiction = async (contradictionId) => {
    const response = await fetch(`/api/contradictions/${contradictionId}`, {
        method: "DELETE",
    });
    return response.json();
};

export const addTimeline = async (timelineData) => {
  try {
    await initializeAuth();
    const sheet = doc.sheetsByTitle['TIMELINES'];
    if (!sheet) {
      throw new Error('TIMELINES sheet not found');
    }

    // Prepare the row data
    const rowData = {
      timeline_id: timelineData.id || uuidv4(),
      title: timelineData.title,
      description: timelineData.description,
      category: timelineData.category,
      is_public: timelineData.is_public ? 'TRUE' : 'FALSE',
      contradiction_id: timelineData.contradiction_id,
      structure_ids: timelineData.structure_ids?.join(',') || '',
      event_ids: timelineData.event_ids?.join(',') || '',
      period_range: timelineData.period_range,
      core_theme: timelineData.core_theme,
      flashpoints: timelineData.flashpoints?.join(',') || '',
      status: timelineData.status,
      timeline_type: timelineData.timeline_type,
      narrative_ids: timelineData.narrative_ids?.join(',') || '',
      linked_phases: timelineData.linked_phases?.map(phase => phase.id).join(',') || '',
      linked_grid_rows: timelineData.linked_grid_rows?.map(row => row.id).join(',') || ''
    };

    // Add the row to the sheet
    await sheet.addRow(rowData);
    return { success: true, id: rowData.timeline_id };
  } catch (error) {
    console.error('Error adding timeline:', error);
    throw error;
  }
};

// Function to fetch and process timeline data
export const getTimelines = async (filters) => {
  try {
    console.log('Fetching timeline data with filters:', filters);
    
    // Log the initialization status
    console.log('Auth initialized:', isInitialized);
    
    // Log the spreadsheet info
    console.log('Spreadsheet ID:', SPREADSHEET_ID);
    
    const [timelines, registry] = await Promise.all([
      fetchSheetData('TIMELINES'),
      fetchSheetData('TIMELINE_REGISTRY')
    ]);

    console.log('Raw timelines data:', timelines);
    console.log('Raw registry data:', registry);

    // Map rows to ensure correct field names and types
    const processedTimelines = timelines.map(timeline => {
      console.log('Processing timeline:', timeline);
      
      // Process linked phases
      const linkedPhases = timeline.linked_phases ? 
        timeline.linked_phases.split(',').map(phaseId => {
          const phase = registry.find(entry => entry.phase_id === phaseId.trim());
          if (!phase) {
            console.log('Phase not found for ID:', phaseId);
            return null;
          }
          return {
            id: phase.phase_id,
            label: phase.phase_label,
            date_range: phase.date_range,
            description: phase.description,
            rupture_rating: parseInt(phase.rupture_rating) || 0,
            linked_events: phase.linked_events ? phase.linked_events.split(',').map(id => id.trim()) : [],
            linked_struggles: phase.linked_struggles ? phase.linked_struggles.split(',').map(id => id.trim()) : [],
            structure_ids: phase.structure_ids ? phase.structure_ids.split(',').map(id => id.trim()) : []
          };
        }).filter(Boolean) : [];

      const processedTimeline = {
        id: timeline.timeline_id,
        title: timeline.title,
        description: timeline.description,
        category: timeline.category,
        is_public: timeline.is_public === 'TRUE',
        contradiction_id: timeline.contradiction_id,
        structure_ids: timeline.structure_ids ? timeline.structure_ids.split(',').map(id => id.trim()) : [],
        event_ids: timeline.event_ids ? timeline.event_ids.split(',').map(id => id.trim()) : [],
        period_range: timeline.period_range,
        core_theme: timeline.core_theme,
        flashpoints: timeline.flashpoints ? timeline.flashpoints.split(',').map(id => id.trim()) : [],
        status: timeline.status,
        timeline_type: timeline.timeline_type,
        narrative_ids: timeline.narrative_ids ? timeline.narrative_ids.split(',').map(id => id.trim()) : [],
        linked_phases: linkedPhases
      };
      
      console.log('Processed timeline:', processedTimeline);
      return processedTimeline;
    });

    console.log('Timelines before filtering:', processedTimelines);
    console.log('Current filters:', filters);

    // Apply filters if provided
    let filteredTimelines = processedTimelines;
    if (filters) {
      console.log('Applying filters:', filters);
      if (filters.search && filters.search.trim() !== '') {
        const searchLower = filters.search.toLowerCase();
        filteredTimelines = filteredTimelines.filter(timeline => 
          timeline.title.toLowerCase().includes(searchLower) ||
          timeline.description.toLowerCase().includes(searchLower)
        );
      }
      if (filters.contradiction && filters.contradiction !== 'all') {
        filteredTimelines = filteredTimelines.filter(timeline => 
          timeline.contradiction_id === filters.contradiction
        );
      }
      if (filters.category && filters.category !== 'all') {
        filteredTimelines = filteredTimelines.filter(timeline => 
          timeline.category === filters.category
        );
      }
    }

    console.log('Final filtered timelines:', filteredTimelines);
    return filteredTimelines;
  } catch (error) {
    console.error('Error fetching timeline data:', error);
    console.error('Error details:', {
      message: error.message,
      stack: error.stack,
      name: error.name
    });
    throw error;
  }
};

export const updateTimeline = async (timelineId, updatedData) => {
    const response = await fetch(`/api/timelines/${timelineId}`, {
        method: "PUT",
        body: JSON.stringify(updatedData),
        headers: { "Content-Type": "application/json" },
    });
    return response.json();
};

export const deleteTimeline = async (timelineId) => {
    const response = await fetch(`/api/timelines/${timelineId}`, {
        method: "DELETE",
    });
    return response.json();
};

export const addStructure = async (structureData) => {
    const response = await fetch("/api/structures", {
        method: "POST",
        body: JSON.stringify(structureData),
        headers: { "Content-Type": "application/json" },
    });
    return response.json();
};

export const getStructures = async () => {
  try {
    const rows = await fetchSheetData('STRUCTURES');
    return rows.map(row => ({
      id: row.structure_id,
      name: row.structure_name,
      type: row.structure_type,
      region: row.region,
      parent_structure: row.parent_structure,
      category: row.category,
      lifespan: row.lifespan,
      transformation_status: row.transformation_status,
      subtype: row.subtype ? row.subtype.split(',').map(s => s.trim()) : [],
      timeline_registry_ids: row.timeline_registry_ids ? row.timeline_registry_ids.split(',').map(id => id.trim()) : [],
      description: row.structure_description,
      historical_range: row.historical_range,
      structure_evolution: row.structure_evolution,
      embedded_contradictions: row.embedded_contradictions ? row.embedded_contradictions.split(',').map(id => id.trim()) : [],
      linked_struggles: row.linked_struggles ? row.linked_struggles.split(',').map(id => id.trim()) : [],
      issue_ids: row.issue_ids ? row.issue_ids.split(',').map(id => id.trim()) : [],
      linked_entities: row.linked_entities ? row.linked_entities.split(',').map(id => id.trim()) : [],
      confidence: parseInt(row.confidence) || 0,
      narratives_shaped_by_structure: row.narratives_shaped_by_structure ? row.narratives_shaped_by_structure.split(',').map(id => id.trim()) : []
    }));
  } catch (error) {
    console.error('Error fetching structures:', error);
    throw error;
  }
};

export const updateStructure = async (structureId, updatedData) => {
    const response = await fetch(`/api/structures/${structureId}`, {
        method: "PUT",
        body: JSON.stringify(updatedData),
        headers: { "Content-Type": "application/json" },
    });
    return response.json();
};

export const deleteStructure = async (structureId) => {
    const response = await fetch(`/api/structures/${structureId}`, {
        method: "DELETE",
    });
    return response.json();
};

export const addRelationship = async (relationshipData) => {
    const response = await fetch("/api/relationships", {
        method: "POST",
        body: JSON.stringify(relationshipData),
        headers: { "Content-Type": "application/json" },
    });
    return response.json();
};

export const getRelationships = async () => {
    const response = await fetch("/api/relationships");
    return response.json();
};

export const updateRelationship = async (relationshipId, updatedData) => {
    const response = await fetch(`/api/relationships/${relationshipId}`, {
        method: "PUT",
        body: JSON.stringify(updatedData),
        headers: { "Content-Type": "application/json" },
    });
    return response.json();
};

export const deleteRelationship = async (relationshipId) => {
    const response = await fetch(`/api/relationships/${relationshipId}`, {
        method: "DELETE",
    });
    return response.json();
};

// Add similar methods for other sheets (e.g., struggles, contradictions, etc.).

// Add this new function
export async function fetchLinkedSheetData(sheetName) {
  try {
    const data = await getSheetData(sheetName);
    return data.map(row => ({
      id: row.id || row[`${sheetName.toLowerCase()}_id`],
      name: row.name || row.WHO || row.headline
    }));
  } catch (error) {
    console.error(`Error fetching linked sheet data for ${sheetName}:`, error);
    return [];
  }
}

export async function getTimelineRegistry() {
  return getSheetData('TIMELINE_REGISTRY');
}

const EntitiesForm = ({ show, onHide, onSubmit }) => {
  const [formData, setFormData] = useState({
    entity_id: '',
    WHO: [],
    SPECTRUM: '',
    bio: '',
    entity_type: '',
    name: '',
    description: ''
  });

  const [entities, setEntities] = useState([]);

  useEffect(() => {
    const fetchEntities = async () => {
      try {
        const data = await getSheetData('ENTITIES');
        if (data && Array.isArray(data)) {
          setEntities(data.map(entity => ({
            value: entity.entity_id || entity.name,
            label: entity.name
          })));
        }
      } catch (err) {
        console.error('Error fetching entities:', err);
      }
    };

    fetchEntities();
  }, []);

  const handleChange = (e) => {
    const { name, value } = e.target;
    setFormData(prev => ({ ...prev, [name]: value }));
  };

  const handleMultiSelectChange = (name, value) => {
    setFormData(prev => ({ ...prev, [name]: Array.isArray(value) ? value : [value] }));
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    try {
      // Map data for ENTITIES table
      const entityData = {
        entity_id: formData.entity_id,
        WHO: formData.WHO,
        bio: formData.bio,
        entity_type: formData.entity_type,
        SPECTRUM: formData.SPECTRUM,
        name: formData.name,
        description: formData.description
      };

      // Add entry to ENTITIES table
      await addRowToSheet('ENTITIES', entityData);
      alert('Data saved successfully!');
      onSubmit();
      onHide();
      setFormData({
        entity_id: '',
        WHO: [],
        SPECTRUM: '',
        bio: '',
        entity_type: '',
        name: '',
        description: ''
      });
    } catch (error) {
      console.error('Error submitting form:', error);
      alert(`Error: ${error.message}`);
    }
  };

  return (
    <Modal show={show} onHide={onHide}>
      <Modal.Header closeButton>
        <Modal.Title>Create New Card</Modal.Title>
      </Modal.Header>
      <Modal.Body>
        <Form onSubmit={handleSubmit}>
          <Form.Group className="mb-3">
            <Form.Label>WHO (Entity Name)</Form.Label>
            <NotionMultiSelect
              options={entities}
              value={formData.WHO}
              onChange={(value) => handleMultiSelectChange('WHO', value)}
              labelledBy="Select WHO"
              allowNew={true}
              placeholder="Search or add new entities..."
            />
          </Form.Group>
          <Form.Group controlId="formSpectrum">
            <Form.Label>Spectrum</Form.Label>
            <Form.Select
              name="SPECTRUM"
              value={formData.SPECTRUM}
              onChange={handleChange}
            >
              <option value="">Select an option</option>
              <option value="LEFT">Left</option>
              <option value="CENTRE">Centre</option>
              <option value="RIGHT">Right</option>
            </Form.Select>
          </Form.Group>
          <Form.Group controlId="formEntityBio">
            <Form.Label>Bio</Form.Label>
            <Form.Control
              type="text"
              name="bio"
              value={formData.bio}
              onChange={handleChange}
            />
          </Form.Group>
          <Form.Group controlId="formEntityType">
            <Form.Label>Entity Type</Form.Label>
            <Form.Select
              name="entity_type"
              value={formData.entity_type}
              onChange={handleChange}
              required
            >
              <option value="">Select an option</option>
              <option value="Character">Character</option>
              <option value="Party">Party</option>
              <option value="Movement">Movement</option>
            </Form.Select>
          </Form.Group>
          <Form.Group controlId="formEntityName">
            <Form.Label>Name</Form.Label>
            <Form.Control
              type="text"
              name="name"
              value={formData.name}
              onChange={handleChange}
            />
          </Form.Group>
          <Form.Group controlId="formEntityDescription">
            <Form.Label>Description</Form.Label>
            <Form.Control
              type="text"
              name="description"
              value={formData.description}
              onChange={handleChange}
            />
          </Form.Group>
          <Button variant="primary" type="submit">
            Submit
          </Button>
        </Form>
      </Modal.Body>
    </Modal>
  );
};

export default EntitiesForm;